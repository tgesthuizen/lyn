\documentclass[12pt, article]{article}

\author{Tim Gesthuizen}
\title{Logbook}

\setlength{\parindent}{0ex}
\setlength{\parskip}{1.5ex}

\usepackage{listings}
\usepackage{hyperref}

\begin{document}

\maketitle

\section{2022-11-17}

\subsection{What happened today?}

\begin{itemize}
\item Parsing works okay for simple programs
\item The scopify and typecheck passes work as well
\item The name of the language is decided to be ``lyn'' for now.
  The short name saves typing and having a name is better than
  bikeshedding for days what would be a good one.
\item Added this document to have a time-representing documentation of
  the project.
\end{itemize}

\subsection{Some questions came up}

\begin{itemize}
\item What would be a good intermediate format to translate to ARM
  instructions? (Suspected to be K-normal forms, like mincaml uses)
\item What would be a good separation for the project?
\item What would be a good first target platform?
\item How would a hand-written recursive descent parser compare to the
  GNU Bison one?
\end{itemize}

\subsection{New ideas}

I guess it would make most sense to develop the compiler in three
pulls:
\begin{enumerate}
\item Build a version that has no primitives nor register allocation
  whatsoever.
  This is easy to implement and a nice comparison for later
  developments.
  Code generated by this version will be trivial and horrible.
\item Then add primitive handling and get rid of some superflous calls
  that can be replaced with simple machine instructions.
\item At last add register allocation.
\end{enumerate}

Maybe step 2 and 3 can be swapped, although it seems safest to
approach it in the way written down.

\subsection{Notes of today}

The amount of memory allocations being done is worrying.
Especially the type system probably needs some reworking before it can
be ported to embedded systems.
Also types are never ever freed by the program yet, but don't tell
anyone.
Right now it seems that types can be dropped after they are checked so
I might just allocate them in a separate heap and drop it altogether
once IR translation has been done.

\section{2022-11-18}

\subsection{What happened today?}

It was decided that ANF (A-normal forms) is the intermediate
representation of choice for now.
A pass that implements the parsed AST into this format has started
being developed.

\subsection{Questions that came up}

Is the way non-tail if expressions are handeled sufficient?
It seems I might need to add phi nodes as SSA compilers like LLVM use
in order to nail the exact details.
I also expect this to lead to some brain melt when developing a proper
register allocator.

\subsection{New ideas}

My view of what the first backend should be is still somewhat vague,
but a textual assembly output seems to be the lowest hanging fruit.
Especially as this can be gracefully expanded to full ELF relocatable
output.
There is also the idea of a makeshift LLVM backend, but this makes
writing an own backend basically obsolete, as there is no need for
it.
Also this approach immediatly destroys any hope of porting the
compiler in the current form onto an embedded platform.

\subsection{Notes of today}

While the ANF pass itself was challenging to implement\footnote{Still
  I got away with implementing it without a design session
  upfront. Wohoo!?}, but of comprehensible complexity, the amount of
details that need adjustment for optimal code generation seems
overwhelming.
I'm not yet bothered as the current goal is getting correct code
generation, not fast code generation, but this is something to keep in
mind.


Sometime soon it might be of value to have some documentation of the
internal structure of the compiler (eww, yet another document to
maintain).
For now I procrastinate on this as I am not yet 100\% convinced that
the current design will work out.

\section{2022-11-19}

\subsection{What happened today?}

Hooked up the ANF pass and found it to be pretty functional.
Fixed a bug here and there and apparently I am able to generate pretty
okay IR code:

\begin{lstlisting}
tibbe@finkpad:~/src/spp$ build/lyn examples/gcd.scm
<global> gcd:
.L0:
        23, 24 <- receive
        25 <- global "="
        26 <- const 0
        27 <- call 25(24, 26)
        if 27: 1 2
.L1:
        ret 23
.L2:
        28 <- global "gcd"
        29 <- global "/"
        30 <- call 29(23, 24)
        tailcall 28(24, 30)
\end{lstlisting}

\subsection{Notes of today}

Unfortunately I noticed that the ARM standard calling convention
prohibits tail calls to functions with more than four arguments.
Think of the following function definition:

\begin{lstlisting}
  (define f
    (lambda (a)
      (g a a a a a a)))
\end{lstlisting}

The function call to g requires two arguments to be passed on the
stack.
In the ARM calling convention the caller must push these arguments to
the stack, adjusting the stack pointer, and also moves the stack
pointer back.
The callee is required to return with the same stack pointer as when
it was entered.
Therefore \texttt{f} cannot tail call \texttt{g} because the caller of
\texttt{f} does not get its stack pointer correctly set back.

For now this is resolved by not allowing tail calls to function with
more than 4 arguments.
In the long run only a change to the calling convention can help.

This is pretty bad as the language has no looping constructs, so
looping with more than 4 variables will eventually blow the stack.
Multiply this with the absent of closures from the language and you
get a significant limitation of the programs expressable.

And yet there is more:
The current way code is generated every function is first loaded as a
function pointer and then jumped to.
However, when a function is now tail called with 4 arguments there is
nowhere to keep the function pointer.
While the first problem could be worked around, this one cannot really
be.
This was the last nail in the coffin to go back to the drawing board
and think about a custom calling convention.
And how interwork with C is going to work.
And how this is later going to affect the register allocated version.
Gnarr\ldots

\section{2022-11-20}

\subsection{What happened today?}

I found that Guy Stelle published a blog article about the very same
problem and proposes the same solution:
\url{https://eighty-twenty.org/2011/10/01/oo-tail-calls}
With the small difference that he already has a compiler or two
working so I can be sure it is a sound idea.

The calling convention was adapted in the following ways:
\begin{itemize}
\item Arguments passed on the stack are now to be cleared by the
  callee, not the caller.
\item Register r4 must not be saved by the callee.
\end{itemize}

These changes allow proper tail calls, possibly to a function
pointer.
The first one is theoretical for now, as functions with more than four
arguments are still outlawed by the compiler.
In addition the second rule might be altered to only allow clobbering
of r4 for functions that have 4 or more arguments as register load is
quite high for Thumb code and stealing one register away from the
caller might result in unneccessary performance penalty.

The compiler was adjusted to generate correct code for
\texttt{examples/identity.scm} and \texttt{examples/gcd.scm}.
However, it is in no way to be trusted to generate correct code yet.

\section{2022-11-21}

\subsection{What happened today?}

Restructured the project layout so that the compiler now lives in its
own subdirectory.
There is no also a runtime library for the target platform.

Wrote a central CMakeLists.txt that's meant to orchestrate a whole
build.
This is yet somewhat problematic because of the building of software
for two different architectures.

The compiler spits out reasonable assembly code for selected
examples.
The next step is to get the first executable linked and running it in
the target environment.

\subsection{Notes of today}

It is tempting to give the compiler some more internal structure and
divide it into front- and backend.
However, this must happen without any performance penalty whatsoever.
In the end this project is about not writing a bloated compiler
framework.

The list of next tasks seems to be long:
\begin{itemize}
\item Lift the 4 argument restriction from functions and calls.
\item Get the first application running
\item Streamline the building/linking process of an application
\item Play around with the compiler for a bit and discover bugs
\item Think about how register allocation can happen
\item Think about how primitives calls can happen more effectively
\item Use a recursive descent parser instead of a Bison parser and see
  which one is preferable
\item Stop types from leaking. Best to be achieved by allocating all
  \texttt{type *}s on a special heap and just dropping the whole thing
  after typechecking.
\item Think about a way to link with non-standard functions
\item Add Bool and Char literals
\item Add missing division primitive function
\end{itemize}

\section{2022-11-22}

\subsection{What happened today?}

Did some refactoring and made minor changes to the language.
Binary and unit constants now work as well.

\section{2022-11-23}

Wrote up a simple wrapper to execute code under qemu process
emulation.
I wrote a small launcher function:
\begin{lstlisting}[language=Assembler]
	.arm
	.section ".text", "ax"
	.global _start
	.type _start, %function
	.func _start, _start
_start:
	sub sp, #8
.L1:
	mov r7, #3 @ sys_read
	mov r0, #0 @ stdin
	mov r1, sp
	mov r2, #8
	swi #0
	cmp r0, #8
	bne .L2
	ldr r0, [sp]
	ldr r1, [sp, #4]
	blx "gcd"
	str r0, [sp]
	mov r7, #4 @ sys_write
	mov r0, #1 @ stdout
	mov r1, sp
	mov r2, #4
	swi #0
.L2:
	add sp, #8
	mov r0, #0
	mov r7, #1 @ sys_exit
	swi #0
\end{lstlisting}

and compiled a basic application using a simple Makefile:
\begin{lstlisting}
gcd: crt0.o gcd.o
	env/bin/arm-none-eabi-ld $^ build/liblyn/liblyn.a -o gcd
%.o: %.s
	env/bin/arm-none-eabi-as $< -c -o $@
gcd.s: examples/gcd.scm
	build/lync/lync -o $@ $<
\end{lstlisting}

After a few minor code generation issues have been fixed I found the
resulting executable to be functional.
The corresponding program looks pretty good when disassembled:

\begin{lstlisting}[language=Assembler, basicstyle=\footnotesize]
gcd:     file format elf32-littlearm


Disassembly of section .text:

00008000 <_start>:
    8000:	e24dd008 	sub	sp, sp, #8
    8004:	e3a07003 	mov	r7, #3
    8008:	e3a00000 	mov	r0, #0
    800c:	e1a0100d 	mov	r1, sp
    8010:	e3a02008 	mov	r2, #8
    8014:	ef000000 	svc	0x00000000
    8018:	e3500008 	cmp	r0, #8
    801c:	1a000008 	bne	8044 <_start+0x44>
    8020:	e59d0000 	ldr	r0, [sp]
    8024:	e59d1004 	ldr	r1, [sp, #4]
    8028:	fa000009 	blx	8054 <gcd>
    802c:	e58d0000 	str	r0, [sp]
    8030:	e3a07004 	mov	r7, #4
    8034:	e3a00001 	mov	r0, #1
    8038:	e1a0100d 	mov	r1, sp
    803c:	e3a02004 	mov	r2, #4
    8040:	ef000000 	svc	0x00000000
    8044:	e28dd008 	add	sp, sp, #8
    8048:	e3a00000 	mov	r0, #0
    804c:	e3a07001 	mov	r7, #1
    8050:	ef000000 	svc	0x00000000

00008054 <gcd>:
    8054:	b543      	push	{r0, r1, r6, lr}
    8056:	b083      	sub	sp, #12
    8058:	4812      	ldr	r0, [pc, #72]	; (80a4 <gcd+0x50>)
    805a:	9002      	str	r0, [sp, #8]
    805c:	f04f 0000 	mov.w	r0, #0
    8060:	9001      	str	r0, [sp, #4]
    8062:	9c02      	ldr	r4, [sp, #8]
    8064:	9804      	ldr	r0, [sp, #16]
    8066:	9901      	ldr	r1, [sp, #4]
    8068:	f000 f81b 	bl	80a2 <gcd+0x4e>
    806c:	9000      	str	r0, [sp, #0]
    806e:	9800      	ldr	r0, [sp, #0]
    8070:	4200      	tst	r0, r0
    8072:	d004      	beq.n	807e <gcd+0x2a>
    8074:	e7ff      	b.n	8076 <gcd+0x22>
    8076:	b080      	sub	sp, #0
    8078:	9803      	ldr	r0, [sp, #12]
    807a:	b005      	add	sp, #20
    807c:	bd40      	pop	{r6, pc}
    807e:	b084      	sub	sp, #16
    8080:	4809      	ldr	r0, [pc, #36]	; (80a8 <gcd+0x54>)
    8082:	9003      	str	r0, [sp, #12]
    8084:	4809      	ldr	r0, [pc, #36]	; (80ac <gcd+0x58>)
    8086:	9002      	str	r0, [sp, #8]
    8088:	9c02      	ldr	r4, [sp, #8]
    808a:	9807      	ldr	r0, [sp, #28]
    808c:	9908      	ldr	r1, [sp, #32]
    808e:	f000 f808 	bl	80a2 <gcd+0x4e>
    8092:	9001      	str	r0, [sp, #4]
    8094:	980a      	ldr	r0, [sp, #40]	; 0x28
    8096:	4686      	mov	lr, r0
    8098:	9c03      	ldr	r4, [sp, #12]
    809a:	9808      	ldr	r0, [sp, #32]
    809c:	9901      	ldr	r1, [sp, #4]
    809e:	b00b      	add	sp, #44	; 0x2c
    80a0:	4720      	bx	r4
    80a2:	4720      	bx	r4
    80a4:	000080b1 	.word	0x000080b1
    80a8:	00008055 	.word	0x00008055
    80ac:	000080b9 	.word	0x000080b9

000080b0 <=>:
    80b0:	1a40      	subs	r0, r0, r1
    80b2:	4243      	negs	r3, r0
    80b4:	4158      	adcs	r0, r3
    80b6:	4770      	bx	lr

000080b8 <%>:
    80b8:	0002      	movs	r2, r0
    80ba:	2301      	movs	r3, #1
    80bc:	4288      	cmp	r0, r1
    80be:	d806      	bhi.n	80ce <%+0x16>
    80c0:	e007      	b.n	80d2 <%+0x1a>
    80c2:	0049      	lsls	r1, r1, #1
    80c4:	005b      	lsls	r3, r3, #1
    80c6:	4281      	cmp	r1, r0
    80c8:	d20c      	bcs.n	80e4 <%+0x2c>
    80ca:	2b00      	cmp	r3, #0
    80cc:	d00a      	beq.n	80e4 <%+0x2c>
    80ce:	2900      	cmp	r1, #0
    80d0:	daf7      	bge.n	80c2 <%+0xa>
    80d2:	4291      	cmp	r1, r2
    80d4:	d800      	bhi.n	80d8 <%+0x20>
    80d6:	1a52      	subs	r2, r2, r1
    80d8:	085b      	lsrs	r3, r3, #1
    80da:	0849      	lsrs	r1, r1, #1
    80dc:	2b00      	cmp	r3, #0
    80de:	d1f8      	bne.n	80d2 <%+0x1a>
    80e0:	0010      	movs	r0, r2
    80e2:	4770      	bx	lr
    80e4:	2b00      	cmp	r3, #0
    80e6:	d1f4      	bne.n	80d2 <%+0x1a>
    80e8:	e7fb      	b.n	80e2 <%+0x2a>
\end{lstlisting}

A few things are noteworthy:
\begin{itemize}
\item The runtime library has indeed the nice property that only used
  functions are actually linked.
\item Not all instructions are Thumb1 yet. This is partially because
  GNU as is configured to assemble for a CPU capable of Thumb2 and
  therefore assembles some instructions as Thumb2 while they could be
  encoded in Thumb1.
\item A trampoline for function calls is needed as there is no Thumb1
  instruction that does ``call with link'' and ``call to address in
  register'' in one go.
\item Note that we are using the builtin GNU ld linker script for this
  application.
  This is a nice property that should be kept.
\item \texttt{objdump} would like to see some EABI tags to give info
  like it would for a GCC program.
  Overall it seems to be somewhat insecure about what it is looking
  at.
  For now this is of lesser importance however.
\end{itemize}

\hline

Quick update: After a short investigation it turns there is a
\texttt{blx} instruction to a register in Thumb1.
I might have missed that by not emitting a \texttt{blx} but a
\texttt{bl} instead because I know for sure that I won't need the
``x'' part in my compiler.
Anyway, after forcing ``armv5t'' as the target architecture of the
assembler and fixing this issue the compiler emits pure and nice
Thumb1 instructions.

\section{2022-11-24}

\subsection{What happened today?}

Today I did a major rewrite of the parser and the memory management of
the compiler.
The parser is now a recursively descent parser, lacking all kinds of
error reporting.
It gets along without exceptions though.
In addition there are dedicated allocators for different memory chunks
now.
All in all the changes of today will help in porting the compiler to
embedded systems.
Also, the size of the resulting binary on AMD64 shrinked from 200kB to
100kB, slicing the size straight in half.

\section{2022-11-28}

\subsection{What happened today?}

Added \texttt{include} and \texttt{declare} top level expressions to
the language.

\section{2022-12-01}

\subsection{What happened today?}

Added some basic unit testing.

\section{2022-12-02}

\subsection{Notes of today}

Today I discovered that LLVM offers three different register
allocators:
\begin{description}
\item[Simple] Is exactly the ``register allocator'' which is currently
  implemented by lync:
  All register values are loaded before an instruction and all results
  are spilled to the stack afterwards.
\item[Local] An improved version of the simple register allocator:
  Registers will be allocated per basic block and live values are
  tried to be kept.
\item[Linear scan] A heavily adapted and modified linear scan
  allocator which is the flag ship register allocation of LLVM.
\end{description}

I think it's pretty interesting that LLVM does not sport graph
coloring register allocations ala Chaitin et al., but uses a linear
scan adaptation instead.
This is nice practical evidence that the result of linear scan
register allocation can stand up to the results of graph coloring
approaches.

\section{2022-12-04}

\subsection{Notes of today}

Implemented inlining of known global functions.
I.e. \texttt{fib} now looks like this:
\begin{lstlisting}
	.arch armv5t
	.thumb
	.syntax unified
	.section ".text", "ax"
	.global "fib-helper"
	.type "fib-helper", %function
	.thumb_func
"fib-helper":
.L1:
	push {r0, r1, r2, r6, lr}
	sub sp, sp, #12
	ldr r0, ="="
	str r0, [sp, #8]
	ldr r0, =#0
	str r0, [sp, #4]
	ldr r4, [sp, #8]
	ldr r0, [sp, #20]
	ldr r1, [sp, #4]
	blx r4
	str r0, [sp, #0]
	ldr r0, [sp, #0]
	tst r0, r0
	beq .L3
	b   .L2
.L2:
	sub sp, sp, #0
	ldr r0, [sp, #12]
	add sp, #24
	pop {r6, pc}
.L3:
	sub sp, sp, #28
	ldr r0, ="fib-helper"
	str r0, [sp, #24]
	ldr r0, ="+"
	str r0, [sp, #20]
	ldr r4, [sp, #20]
	ldr r0, [sp, #40]
	ldr r1, [sp, #44]
	blx r4
	str r0, [sp, #16]
	ldr r0, ="-"
	str r0, [sp, #12]
	ldr r0, =#1
	str r0, [sp, #8]
	ldr r4, [sp, #12]
	ldr r0, [sp, #48]
	ldr r1, [sp, #8]
	blx r4
	str r0, [sp, #4]
	ldr r0, [sp, #56]
	mov lr, r0
	ldr r4, [sp, #24]
	ldr r0, [sp, #44]
	ldr r1, [sp, #16]
	ldr r2, [sp, #4]
	add sp, #60
	bx r4
	.pool
	.size "fib-helper", .-"fib-helper"
	.global "fib"
	.type "fib", %function
	.thumb_func
"fib":
.L4:
	push {r0, r6, lr}
	sub sp, sp, #16
	ldr r0, ="fib-helper"
	str r0, [sp, #12]
	ldr r0, =#1
	str r0, [sp, #8]
	ldr r0, =#1
	str r0, [sp, #4]
	ldr r0, [sp, #24]
	mov lr, r0
	ldr r4, [sp, #12]
	ldr r0, [sp, #8]
	ldr r1, [sp, #4]
	ldr r2, [sp, #16]
	add sp, #28
	bx r4
	.pool
	.size "fib", .-"fib"
\end{lstlisting}
instead of this
\begin{lstlisting}
	.arch armv5t
	.thumb
	.syntax unified
	.section ".text", "ax"
	.global "fib-helper"
	.type "fib-helper", %function
	.thumb_func
"fib-helper":
.L1:
	push {r0, r1, r2, r6, lr}
	sub sp, sp, #8
	ldr r0, =#0
	str r0, [sp, #4]
	ldr r0, [sp, #16]
	ldr r1, [sp, #4]
	blx "="
	str r0, [sp, #0]
	ldr r0, [sp, #0]
	tst r0, r0
	beq .L3
	b   .L2
.L2:
	sub sp, sp, #0
	ldr r0, [sp, #8]
	add sp, #20
	pop {r6, pc}
.L3:
	sub sp, sp, #16
	ldr r0, [sp, #24]
	ldr r1, [sp, #28]
	blx "+"
	str r0, [sp, #12]
	ldr r0, =#1
	str r0, [sp, #8]
	ldr r0, [sp, #32]
	ldr r1, [sp, #8]
	blx "-"
	str r0, [sp, #4]
	ldr r0, [sp, #40]
	mov lr, r0
	ldr r0, [sp, #28]
	ldr r1, [sp, #12]
	ldr r2, [sp, #4]
	add sp, #44
	bx "fib-helper"
	.pool
	.size "fib-helper", .-"fib-helper"
	.global "fib"
	.type "fib", %function
	.thumb_func
"fib":
.L4:
	push {r0, r6, lr}
	sub sp, sp, #12
	ldr r0, =#1
	str r0, [sp, #8]
	ldr r0, =#1
	str r0, [sp, #4]
	ldr r0, [sp, #20]
	mov lr, r0
	ldr r0, [sp, #8]
	ldr r1, [sp, #4]
	ldr r2, [sp, #12]
	add sp, #24
	bx "fib-helper"
	.pool
	.size "fib", .-"fib"
\end{lstlisting}

The new code tends to be a lot shorter and also safes a lot of stack
space and reduces register pressure.

\section{2022-12-10}

\subsection{What happened today?}

Finalized a bugfix where the typechecker failed to check types of
function declarations.
This is now corrected.
It is not perfect yet though, as the definition of a function will be
unified with the type unified from its usages and declaration.
This may lead to error messages which seem ``the wrong way around''
for functions without declarations:
If the function is used before its definition the error message might
say that the function definition does not fit the type deduced from
the call site which location is no longer tracked.
This is not really helpful for debugging the call site.
Thankfully this problem does not occur when functions are defined
before their first usage as required by C or when a declaration is
present.

Overall I worked on some fortification of the compiler the last few
days but failed to record what I did precisely.

\section{2023-01-07}

\subsection{What happened today?}

Quite some time has passed since the last entry.
I tried implementing a thing or two in between but was stopped by the
following issue:
The way the compiler handeled variabel scoping with functions was
incorrect.
This was disguised by a minor error in the parser.
Solving this issue was surprisingly complicated.
Furthermore I'm not quite happy with the way it is implemented right
now.
The root of the issue is that alpha conversion happens before
typechecking but different scoping rules apply to an expression of
function type than other expressions.

It is solved now by the following wonky semantics:
Local functions can now refer to each other when they are defined in a
\lstinline{let rec}.
The context of this declaration is not of relevance however, functions
bound by prior \lstlinline{let} and \lstinline{let rec} expressions
will not be visible.
E.g. this is okay:

\lstinputlisting{../examples/recursive-even-odd.scm}

but this is not:

\begin{lstlisting}
  (let ((plus2 (lambda (x) (+ x 2))))
    (let ((plus3 (lambda (x) (+ (plus2 x) 1))))
      (plus3 2)))
\end{lstlisting}

In order to get ``proper'' Scheme-like scoping the alpha conversion
and typechecking passes would need to be merged.
Which is not impossible, but a bunch of extra work.
Furthermore it's a pitty because they are so nicely separated in their
current form.

Afterwards I was fighting with the code generation because it didn't
cope well with the new local functions.
Especially the dead code elimination showed itself to be pretty
buggy.
To say it in the words of Donald Knuth, though veeery out of context:
``Premature optimization is the root of all evil''

\section{2023-01-09}

\subsection{Notes of today}

Further investigations reveal that the current problem is much deeper
rooted.
After fixing the most apparent error it turns out that code generation
fails for various reasons.
The most fundamental one can be observed with the new
recursive-even-odd example:
The functions defined recursively are generated incorrectly as they do
not reload the other functions defined with them but just defined on
an existing stack slot holding their address.
Furthermore, it needs to be forbidden to have functions defined
anywhere but in \texttt{let rec}s be available in nested, local
functions.
Otherwise the lines between local calculations, which fall under the
no-clojures rule of the language, and proper local function
definitions are too blurred.

\section{2023-02-06}

\subsection{What happened today?}

I reverted the experiments with recursive local definitions as code
generation for them was horribly broken.
It turns out that comming up with a solid concept for translating
these aspects is surprisingly difficult and I often ended up
implementing broken language definitions.
Therefore, the ``final'' language is the old one which relies on
global helper definitions for recursion.
It doesn't take away any expressiveness from the language but reduces
encapsulation and local definitions would allow for more natural
expression of loops.

\subsection{Notes of today / Summary}

The project was really ambitious from the start.
The end result implements the most fundamental features but misses a
few bits I wanted to implement.
The compiler is written in completely standards compliant C++ and uses
memory partitions for its different data structures.
Therefore it can be easily ported to embedded systems and is nicely
tweakable with regards to memory management.
Furthermore, the lack of optimization makes the runtime of the
compiler pretty linear with its input size.
The language is able to interface with functions written in C or
assembler.
Some noteworthy things I would have liked but could not get
implemented in time:

\begin{itemize}
\item Register allocation
\item An in-depth example
\item ELF relocatable object output
\end{itemize}

Lessons learned during this project:

\begin{itemize}
\item Coming up with a language without loop holes is difficult,
  better choose something existing and established.
\item Compilers are hard, writing a correct one in a comfy environment
  is quite a challenge already.
\item Supporting multiple output formats, freely arrangeable passes,
  etc. increases the difficulty of getting the compiler right
  exponentially.
  In hindsight my idea to support three backends, textual assembly
  output, ELF relocatables and in-memory code emission was way too
  ambitious.
  This also applies to other decisions.
\item Embedded systems are hard.
  Creating the right toolchain, building working ROM-images and
  debugging real hardware is very time consuming.
  Multiply this with the time consuming nature of writing a compiler
  and you'll find out that a compiler for embedded systems is
  incredibly time consuming to develop.
\item Time is the name of the game.
  While I spend a whole load of time in the beginning to get the
  compiler working my focus shifted to other courses as they got more
  work intensive later and I just lacked the manpower to finish some
  aspects I anticipated.
\end{itemize}

Now to the positives of the project, which shouldn't be forgotten
after all the notes above:

\begin{itemize}
\item The compiler is functional for a small but self-developed toy
  language.
  With the right function it should be turing complete and the
  compiler could be used as is to develop real world software.
  This alone is quite an accomplishment in my opinion.
\item The compiler has very flexible memory management, making it
  easier to handle in memory constrained environments.
\item Code generated by the compiler was run under real hardware
  (Raspberry Pi), a corresponding emulation platform was also setup
  using QEMUs Linux process emulation.
\item The project is written in generic C++17 and should be runable as
  is on a lot of platforms without any tweaking.
\item I must say that I really like the organization of the compiler
  and source code.
  Obviously I, the sole author, am the wrong person to answer this
  question though.
\item The compiler project is in good shape to be easily extended.
\end{itemize}

\end{document}
